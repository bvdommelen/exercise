using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ProjectEuler
{
    /*
     * The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
     * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
     * Let us list the factors of the first seven triangle numbers:
     * 1: 1
     * 3: 1,3
     * 6: 1,2,3,6
     * 10: 1,2,5,10
     * 15: 1,3,5,15
     * 21: 1,3,7,21
     * 28: 1,2,4,7,14,28
     * We can see that 28 is the first triangle number to have over five divisors.
     * What is the value of the first triangle number to have over five hundred divisors?
     */
    public class Problem12
    {
        public string Solve()
        {
            // Generate a prime table to eliminate duplication of prime number generation
            // Note that due to the algorithm used primes<1000 are far sufficient for our cause!
            var primeTable = PrimeHelper.AllPrimes(1000);
            /*
             * Triangle numbers can be rewritten as n*(n+1)/2.
             * As n and n+1 are coprime (they share no prime factors) the solution can be simplified to
             * D(n*(n+1)/2)=>D(n)*D((n+1)/2) if n+1%2 and D(n/2)*D(n+1) if n%2.
             * We could furthermore re-use the number of factors in D(n+1) for our next run in n reducing the number of calculations in half.
             */
            for (int t = 1; ; t++)
            {
                long d1 = this.GetDivisorCount(t % 2 == 0 ? t / 2 : t, primeTable);
                long d2 = this.GetDivisorCount(t % 2 == 0 ? t + 1 : (t + 1) / 2, primeTable);
                if (d1*d2 > 500) return (t * (t + 1) / 2).ToString();
            }
        }

        private int GetDivisorCount(long number, IEnumerable<long> primeTable)
        {
            /*
             * Every positive integer has a unique prime factorization. So your products will all be of the form
             * 11^a⋅7^b⋅5^c⋅3^d⋅2^e
             * where 0≤a,b,c,d,e 
             * Which gives you
             * (a+1)*(b+1)*(c+1)*(d+1)*(e+1) possibilities (each factor can be present 0..n times in the final product).
             * The general form for this equation is:
             * (k1 + 1)⋅(k2 + 1)⋯(kn + 1) = (∏i = 1n(ki + 1))
             * distinct products
             */
            var allFactors = PrimeHelper.AllFactors(number, primeTable);
            /*
             * Once we know all prime factors (multiples allowed), we can group them by value into a grouping that projects each prime factor to how often it occurs:
             * {2,2,2,3,5,5,5} => Grouping<long,int> {2,3},{3,1},{5,3}.
             * The number of distinct products is then (3+1)*(1+1)*(3+1)
             */
            return allFactors
                .GroupBy(f => f)                    // Group by value of factor
                .Select(g => g.Count() + 1)         // Determine size of each group + 1
                .Aggregate(1, (x, y) => x * y);     // Multiply group sizes
        }
    }
}
